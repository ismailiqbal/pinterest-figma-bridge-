<!DOCTYPE html>
<html>
<head>
  <style>
    body { font-family: Inter, sans-serif; padding: 20px; text-align: center; color: #333; }
    h2 { font-size: 16px; font-weight: 600; margin-bottom: 8px; }
    .code-box {
      background: #F0F0F0; border: 1px solid #E5E5E5; border-radius: 8px;
      padding: 16px; margin: 16px 0; font-family: 'Courier New', monospace;
      font-size: 24px; letter-spacing: 4px; font-weight: bold; color: #333; user-select: text; cursor: pointer;
    }
    .status { font-size: 12px; color: #888; margin-top: 8px; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 6px; }
    .dot { width: 8px; height: 8px; border-radius: 50%; background: #ccc; display: inline-block; }
    .dot.connected { background: #00C853; box-shadow: 0 0 4px #00C853; }
    .error-log { color: #E00; font-size: 10px; margin-top: 5px; max-width: 100%; word-break: break-all; }
    
    .settings { margin-top: 20px; border-top: 1px solid #eee; padding-top: 10px; text-align: left; }
    .settings summary { font-size: 11px; color: #888; cursor: pointer; }
    .settings input { width: 100%; box-sizing: border-box; padding: 6px; margin-top: 5px; font-size: 12px; border: 1px solid #ddd; border-radius: 4px; }
    .settings button { margin-top: 5px; padding: 4px 8px; font-size: 11px; cursor: pointer; background: #eee; border: none; border-radius: 3px; }
    
    p { font-size: 11px; color: #666; line-height: 1.4; }
  </style>
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
</head>
<body>
  <h2>Pinterest Bridge</h2>
  
  <div class="code-box" id="codeDisplay" title="Click to copy">...</div>
  
  <div class="status">
    <div>
      <span class="dot" id="statusDot"></span>
      <span id="statusText">Connecting...</span>
    </div>
    <div id="errorLog" class="error-log"></div>
  </div>


  <script>
    // Production server URL (hardcoded)
    const SERVER_URL = 'https://pinterest-figma-bridge.onrender.com';

    const codeDisplay = document.getElementById('codeDisplay');
    const statusDot = document.getElementById('statusDot');
    const statusText = document.getElementById('statusText');
    const errorLog = document.getElementById('errorLog');

    let socket = null;
    let ROOM_ID = Math.floor(100000 + Math.random() * 900000).toString();
    codeDisplay.textContent = ROOM_ID;

    // Copy Code on Click
    codeDisplay.addEventListener('click', () => {
      const ta = document.createElement('textarea');
      ta.value = ROOM_ID;
      document.body.appendChild(ta);
      ta.select();
      document.execCommand('copy');
      document.body.removeChild(ta);
      const original = codeDisplay.textContent;
      codeDisplay.textContent = 'COPIED';
      setTimeout(() => codeDisplay.textContent = original, 1000);
    });

    function connect() {
      if (socket) socket.disconnect();
      
      console.log('Connecting to:', SERVER_URL);
      statusText.textContent = 'Connecting...';
      statusDot.className = 'dot';
      errorLog.textContent = '';

      // Use websocket for production HTTPS
      socket = io(SERVER_URL, {
        transports: ['websocket', 'polling'],
        reconnectionAttempts: 10,
        timeout: 10000
      });

      socket.on('connect', () => {
        statusDot.classList.add('connected');
        statusText.textContent = 'Connected & Ready';
        errorLog.textContent = '';
        console.log('Socket connected, joining room:', ROOM_ID);
        socket.emit('join-room', ROOM_ID);
      });

      socket.on('joined', (data) => {
        console.log('Successfully joined room:', data.roomId);
        errorLog.textContent = 'Room: ' + data.roomId;
      });

      socket.on('connect_error', (err) => {
        statusDot.classList.remove('connected');
        statusText.textContent = 'Connection Error';
        errorLog.textContent = err.message;
      });

      socket.on('disconnect', () => {
        statusDot.classList.remove('connected');
        statusText.textContent = 'Disconnected';
      });

      socket.on('new-image', async (data) => {
        console.log('NEW IMAGE EVENT RECEIVED:', data);
        statusText.textContent = 'Receiving...';
        errorLog.textContent = 'Got image: ' + data.url.substring(0, 30) + '...';
        try {
          let bytes;
          
          // Check if it's a data URL (base64) or regular URL
          if (data.url.startsWith('data:')) {
            // Data URL - decode base64 correctly
            const parts = data.url.split(',');
            if (parts.length < 2) {
              throw new Error('Invalid data URL format');
            }
            const base64Data = parts[1];
            // Decode base64 to binary string
            const binaryString = atob(base64Data);
            // Convert binary string to Uint8Array
            bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
              bytes[i] = binaryString.charCodeAt(i);
            }
          } else {
            // Regular URL - use proxy endpoint to avoid CORS
            const BRIDGE_SERVER_URL = 'https://pinterest-figma-bridge.onrender.com';
            const proxyUrl = `${BRIDGE_SERVER_URL}/proxy-image?url=${encodeURIComponent(data.url)}`;
            console.log('Fetching via proxy:', proxyUrl);
            
            const response = await fetch(proxyUrl);
            if (!response.ok) {
              throw new Error('Failed to fetch image via proxy: ' + response.status);
            }
            const result = await response.json();
            
            if (!result.dataUrl) {
              throw new Error('Proxy did not return dataUrl');
            }
            
            // Decode the data URL from proxy
            const parts = result.dataUrl.split(',');
            if (parts.length < 2) {
              throw new Error('Invalid data URL format from proxy');
            }
            const base64Data = parts[1];
            const binaryString = atob(base64Data);
            bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
              bytes[i] = binaryString.charCodeAt(i);
            }
          }
          
          // Validate bytes
          if (!bytes || bytes.length === 0) {
            throw new Error('Image data is empty after decoding');
          }
          
          // Convert Uint8Array to regular Array for postMessage serialization
          const bytesArray = Array.from(bytes);

          parent.postMessage({ 
            pluginMessage: { 
              type: 'create-image', 
              bytes: bytesArray,
              width: data.width,
              height: data.height
            } 
          }, '*');

          statusText.textContent = 'Image added!';
          setTimeout(() => { statusText.textContent = 'Connected & Ready'; }, 2000);
        } catch (err) {
          console.error('Error fetching image:', err);
          statusText.textContent = 'Error downloading';
          errorLog.textContent = err.message;
        }
      });
    }

    // Initial Connect
    connect();
  </script>
</body>
</html>
